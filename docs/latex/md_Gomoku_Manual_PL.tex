\hypertarget{md_Gomoku_Manual_PL_autotoc_md1}{}\doxysection{Kompilacja}\label{md_Gomoku_Manual_PL_autotoc_md1}
\begin{quote}
{\bfseries{Uwaga}} Program korzysta z biblioteki G\+T\+K+ 3.\+0 \end{quote}


Wystarczy wykonać komendę {\ttfamily make}\hypertarget{md_Gomoku_Manual_PL_autotoc_md2}{}\doxysection{Krótka dokumentacja}\label{md_Gomoku_Manual_PL_autotoc_md2}
Program otwiera się~na ekranie menu, na którym po wybraniu kolor gracza -\/ gra automatycznie tworzy {\itshape lobby} i oczekuje na dołączenie do gry przez drugiego gracza. Drugi gracz nie będzie miał możliwości stworzenia własnego lobby, ponieważ program wykryje, że już~jedno {\itshape lobby} istnieje w danym folderze (Lobby jest named pipe\textquotesingle{}em).

Rozgrywka toczy się~turowo. Zaczyna gracz czarny. Zawodniczy grają nawzajem dopóki\+:


\begin{DoxyEnumerate}
\item Plansza się zapełni
\item Któryś z graczy wyjdzie z gry
\item Wygra któryś~z graczy
\end{DoxyEnumerate}

Celem gracza jest ułożenie 5 pionków w poziomie, pionie lub skosie. Gra zależna jest od obrazków oraz pliku C\+SS.\hypertarget{md_Gomoku_Manual_PL_autotoc_md3}{}\doxysection{Architektura programu}\label{md_Gomoku_Manual_PL_autotoc_md3}
Program składa się~z następujących modułów\+:


\begin{DoxyItemize}
\item {\bfseries{game}} -\/ moduł obsługujący mechanizm rozgrywki, sprawdzania, czy któryś z graczy wygrał oraz podsumowywania rozgrywki odpowiednim opisem stanu gry.
\item {\bfseries{gtkui}} -\/ moduł ułatwiający programowanie z biblioteką w G\+T\+K+ 3.\+0. Napisany został przeze mnie i kolegę z grupy. Chcieliśmy zbudować czysty i przejrzysty kod, dla większej czytelności i zwiększonej wydajności pracy. Moduł ten jest udostępniony publicznie i można przejrzeć jego zawartość~pod tym linkiem\+: \href{https://github.com/Ph0enixKM/GTK-UI}{\texttt{ G\+T\+K-\/\+UI}}
\item {\bfseries{include}} -\/ moduł zawierający glabalny plik nagłówkowy z którego inne moduły korzystają by móc otrzymać~dostęp do niektórych funkcji z innych modułów oraz zmiennych globalnych. Ponad to zawiera funkcje alokowania pamięci oraz uwalniania jej na początku i pod koniec programu.
\item {\bfseries{lobby}} -\/ moduł obsługujący całą strukturę behawioralną lobby oraz dołączania do istniejącego lobby. Ponad to zawiera również funkcję~konstuującą ów lobby.
\item {\bfseries{menu}} -\/ moduł obsługujący cały mechanizm związany z menu, jego interfacem oraz interakcją użytkownika.
\item {\bfseries{talk}} -\/ moduł umożliwiający komunikację między programami. Moduł używa named pipe (F\+I\+FO) do komunikacji. Nie każdą funkcję~użyłem w tym module, ponieważ pisałem go na wyrost przed zabraniem się~za cały projekt, żeby przygotować sobie dobre fundamenty.
\item {\bfseries{utils}} -\/ moduł zawierający funkcje które nie koniecznie są związane z jakimś~modułem, albo uznałem, że nie pasują~do żadnego.
\end{DoxyItemize}\hypertarget{md_Gomoku_Manual_PL_autotoc_md4}{}\doxysubsection{Struktury}\label{md_Gomoku_Manual_PL_autotoc_md4}
Nie korzystałem z wielu struktur, ponieważ udało mi się~wiele problemów rozwiązać bez ich potrzeby. Przykładem może być chociaż by przesył danych między programami. Wykonałem go korzystając z tablicy charów zamiast przesyłając strukturę. Dało mi to między innymi większą swobodę do debugowania mojego programu.


\begin{DoxyItemize}
\item Struktura {\bfseries{\mbox{\hyperlink{structPos}{Pos}}}}
\end{DoxyItemize}

  

Zawiera ona informacje o pozycji polu na planszy. Wykorzystywana jest przy sprawdzaniu czy pewne dokładnie 5 pól spełniają oczekiwania wygrania rozgrywki przez pewnego gracza w funkcji {\ttfamily player\+Check()} w pliku {\itshape \mbox{\hyperlink{check_8c}{game/check.\+c}}}. Każde takie pole jest zapisywane w tablicy globalnej {\itshape trace}. Z niej korzysta funkcja {\ttfamily \mbox{\hyperlink{game_8c_a5bd3a9679cacce3db7c0aa1f22fbec0d}{game\+Over()}}} w pliku {\itshape \mbox{\hyperlink{game_8c}{game/game.\+c}}} która podświetla pola zwycięzcy pod koniec gry.


\begin{DoxyItemize}
\item Struktura {\bfseries{\mbox{\hyperlink{structTlkPipe}{Tlk\+Pipe}}}}
\end{DoxyItemize}

  

Zawiera ona informacje o aktualnie otwartym named pipe\textquotesingle{}u. Są to informacje takie jak\+: tryb otwarcia (zapis, odczyt), rozmiar bufora, stan otwarcia oraz deskryptor pliku (file descriptor). Struktura ta jest ściśle wykorzystywana przez funkcje związane z modułem {\bfseries{talk}}. W Headerze tego pliku możemy zauważyć komentarze, które odnoszą się~do funkcji korzystających z tej struktury. Reszta funkcji działa tak, że otwierają, zapisują lub odczytują a następnie zamykają named pipe\textquotesingle{}a (Nie koniecznie wszystkie mi były potrzebne podczas rozwoju mojego programu).\hypertarget{md_Gomoku_Manual_PL_autotoc_md5}{}\doxysubsection{Funkcje}\label{md_Gomoku_Manual_PL_autotoc_md5}
Program korzysta z wielu funkcji. Nie będę~omawiać wszystkich, ponieważ niektóre są to funkcje wykonujące drobne, czasem wręcz oczywiste operacje. Inne są zaś callbackami funkcji macierzystych, które właśnie zamierzam przedstawić.

\begin{quote}
Plik {\itshape \mbox{\hyperlink{main_8c}{main.\+c}}} \end{quote}



\begin{DoxyItemize}
\item Zaczynając od funkcji {\ttfamily \mbox{\hyperlink{main_8c_a0ddf1224851353fc92bfbff6f499fa97}{main()}}}, która jest najważniejszą funkcją w całym programie. Wywołuje ona funkcje najwyższego poziomu tj.
\begin{DoxyItemize}
\item Inicjalizowanie globalnych zmiennych
\item Ładowanie pliku stylów C\+SS (którą zaimplementowałem w {\bfseries{G\+T\+K-\/\+UI}})
\item Tworzenie głównego okna
\item Tworznie stacku który jest odpowiedzialny za przełączanie scen $\ast$(takich jak menu, game, wait)$\ast$
\item Konstruowanie sceny Lobby
\item Konstruowanie sceny Menu
\item Przełączenie się~na scenę Menu
\item Podłączanie głównego okna do eventu {\itshape destroy}
\end{DoxyItemize}
\end{DoxyItemize}

\begin{quote}
Plik {\itshape \mbox{\hyperlink{menu_8c}{menu/menu.\+c}}} \end{quote}



\begin{DoxyItemize}
\item Funkcja {\ttfamily \mbox{\hyperlink{menu_8c_ab831fe7c991e2f59d5a655fa1eea199f}{create\+Menu()}}} konstruuje menu tworząc logo, oraz dodawając stack jako drugi widget w tej scenie. W tym stacku przechowywane są dwie podsceny -\/ host oraz join.
\begin{DoxyItemize}
\item {\bfseries{host}} -\/ zawiera wybór między dwoma kolorami pionków -\/ biały lub czarny. Wybór powoduje stworzenie się lobby oraz przełączenie użytkownika na ekran oczekiwania na drugiego gracza.
\item {\bfseries{join}} -\/ zawiera przycisk dołączający do rozgrywki. Po naciśnięciu w ten przycisk program podłączy się~do istniejącego lobby i rozpocznie rozgrywkę.
\end{DoxyItemize}

Warto wspomnieć, że istnieje funkcja która co jakiś~czas sprawdza, czy czasem nie istnieje lobby. W takim przypadku przełącza stack na {\bfseries{join}}. Natomiast jeśli lobby zniknie (patrz\+: host wyłączy okno tym samym usunie lobby) -\/ stack użytkownika drugiego automatycznie to wykryje i przełączy stack na {\bfseries{host}}.
\end{DoxyItemize}

\begin{quote}
Plik {\itshape \mbox{\hyperlink{game_8c}{game/game.\+c}}} \end{quote}



\begin{DoxyItemize}
\item Funkcja {\ttfamily \mbox{\hyperlink{game_8c_ab81d43d8c165bb0345a538c2ad058b73}{create\+Game()}}} kosntruuje wygląd rozgrywki jednocześnie podpinając odpowiednie callbacki do różnych pól. Plansza jest tworzona przy pomocy widgetu grid w zmiennej {\itshape ui\+\_\+grid}. Inna globala zmienna użyta w tej funkcji to {\itshape ui\+\_\+status}, która zawiera informacje o stanie gry. To czy któryś z graczy wygrał, czy plansza się~zapełniła, czy któryś z graczy odszedł od gry -\/ to wszystko jest pokazywane przy pomocy tego widgetu. Ponad to globalnie przechowuję dwie tablice\+:
\begin{DoxyItemize}
\item {\bfseries{fields}} -\/ przechowuje dane na temat tego gdzie użytkownik położył pionek i jakiego on jest koloru
\item {\bfseries{btns}} -\/ przechowuje wszystkie widgety z planszy (buttony) które są później wykorzystywane m.\+in. do podświetlania pól.
\end{DoxyItemize}
\end{DoxyItemize}

\begin{quote}
Plik {\itshape \mbox{\hyperlink{check_8c}{game/check.\+c}}} \end{quote}



\begin{DoxyItemize}
\item funkcja {\ttfamily \mbox{\hyperlink{check_8c_aa336cc3e16e7769af706adcd665f485e}{game\+Check()}}} sprawdza po pierwsze czy plansza jest pełna, a następnie przechodzi do sprawdzania czy któryś z graczy wygrał. Do tego wykorzystuje funkcję~{\ttfamily player\+Check()} która jest zamieszczona w tym samym pliku. Funkcja ta iteruje w każdy możliwy sposób (tj. pion, poziom i ukosy) by sprawdzić czy dany gracz wygrał czy przegrał.
\end{DoxyItemize}\hypertarget{md_Gomoku_Manual_PL_autotoc_md6}{}\doxysection{Podsumowanie}\label{md_Gomoku_Manual_PL_autotoc_md6}
Ten projekt sprawił, że prawdziwie polubiłem język C. Jest to mój pierwszy poważny projekt, który napisałem w tym języku i od razu polubiłem swoistą minimalistyczność C. Co prawda były momenty kiedy tęksniłem za obiektowym paradygmatem, ale w pewnym momencie zrozumiałem, że tak naprawdę~to wszystko siedzi w głowie.

{\itshape Paweł Karaś} 